#!/usr/bin/env bash

# config
BRANCHES=("prod" "staging")
PROJECT_PREFIX="cc-"
WORK_TREE_DIR="/home/git/worktrees"

while read oldrev newrev ref; do
  branch=`echo $ref | rev | cut -d / -f 1 | rev`
  if [[ " ${BRANCHES[*]} " =~ " $branch " ]]; then
    echo "Ref $ref received. Deploying [$branch]..."

    # set env vars for git
    export GIT_DIR=`pwd`
    export GIT_WORK_TREE="$WORK_TREE_DIR/services"

    # check out to worktree
    mkdir -p $GIT_WORK_TREE
    git checkout -f $branch
    cd $GIT_WORK_TREE

    # get commit hash for main repo
    COMMIT_HASH=$(git rev-parse HEAD | head -c 7)
    echo "Current services commit hash: $COMMIT_HASH"

    # update status
    echo "Updating deployment status..."
    echo `jq \
      --arg commit "$COMMIT_HASH" \
      --arg timestamp "$(TZ='Asia/Kolkata' date --iso-8601=ns | cut -d, -f1)" \
      --arg environment "$branch" \
      '.commit = $commit | .timestamp = $timestamp | .environment = $environment' \
      nginx/static/json/status.json` > nginx/static/json/status.json

    # configure local submodule repos
    if [ -f .gitmodules ]; then
      sed -i "s|git@github.com:Clubs-Council-IIITH|$HOME|g" .gitmodules
      echo "Configured local submodule repositories."
    else
      echo ".gitmodules file not found!"
    fi

    # git submodule add -b origin/$branch $HOME/services.git
    # rm services/.gitmodules

    # pull submodules (except auth-dev)
    git -c submodule.apis/auth-dev.update=none submodule update --init

    # update changelog
    echo "Updating changelog..."
    git submodule foreach \
      'git log --no-merges --oneline --since="1 year ago" --date=short --pretty=format:"**%ad:** [$name] %s  " | 
      grep -v -e "Apply Linting & Formatting Fixes" -e "Apply Prettier Formatting Fixes" | 
      grep -vi "sitemap" |
      cat && echo' \
      | grep -v ^Entering | sort -r -o nginx/static/mdx/logs.mdx

    # extract commit hashes for each microservice
    echo "Extracting commit hashes for microservices..."

    # Unset GIT_DIR and GIT_WORK_TREE to work with submodules
    unset GIT_DIR
    unset GIT_WORK_TREE
    
    # Main services
    export IMAGE_TAG_WEB=$(git -C web log --pretty=format:'%h' -n 1)
    export IMAGE_TAG_GATEWAY=$(git -C gateway log --pretty=format:'%h' -n 1)
    export IMAGE_TAG_AUTH=$(git -C apis/auth log --pretty=format:'%h' -n 1)
    export IMAGE_TAG_FILES=$(git -C apis/files log --pretty=format:'%h' -n 1)
    
    # Subgraphs
    export IMAGE_TAG_INTERFACES=$(git -C subgraphs/interfaces log --pretty=format:'%h' -n 1)
    export IMAGE_TAG_CLUBS=$(git -C subgraphs/clubs log --pretty=format:'%h' -n 1)
    export IMAGE_TAG_MEMBERS=$(git -C subgraphs/members log --pretty=format:'%h' -n 1)
    export IMAGE_TAG_EVENTS=$(git -C subgraphs/events log --pretty=format:'%h' -n 1)
    export IMAGE_TAG_USERS=$(git -C subgraphs/users log --pretty=format:'%h' -n 1)

    # Check if the docker images with these tags exist, if not, fallback to 'latest'
    for service in web gateway auth files interfaces clubs members events users; do
      image_name="$PROJECT_PREFIX$service"
      image_tag_var="IMAGE_TAG_${service^^}"
      image_tag=${!image_tag_var}
      if [[ -z $(docker images -q "$image_name:$image_tag") ]]; then
        echo "Image $image_name with tag $image_tag not found. Falling back to 'latest' tag."
        export $image_tag_var="latest"
      fi
    done

    echo "Using Image tags:"
    echo "  web: $IMAGE_TAG_WEB"
    echo "  gateway: $IMAGE_TAG_GATEWAY"
    echo "  auth: $IMAGE_TAG_AUTH"
    echo "  files: $IMAGE_TAG_FILES"
    echo "  interfaces: $IMAGE_TAG_INTERFACES"
    echo "  clubs: $IMAGE_TAG_CLUBS"
    echo "  members: $IMAGE_TAG_MEMBERS"
    echo "  events: $IMAGE_TAG_EVENTS"
    echo "  users: $IMAGE_TAG_USERS"

    # deploy new images with commit hash tags
    echo "Building and deploying services..."

    # Check for envsubst
    if ! command -v envsubst &> /dev/null; then
        echo "Error: envsubst not found. Please install gettext-base."
        exit 1
    fi

    # Migration: Check for legacy containers and stop them
    # This is mostly needed only for the first run after architecture change
    LEGACY_MONGO="${PROJECT_PREFIX}${branch}-mongo-1"
    LEGACY_NGINX="${PROJECT_PREFIX}${branch}-nginx-1"
    
    if [ -n "$(docker ps -q -f name=$LEGACY_MONGO)" ]; then
        echo "Stopping legacy mongo to allow shared stack to start..."
        docker stop $LEGACY_MONGO || true
        docker rm $LEGACY_MONGO || true
    fi
    
    if [ -n "$(docker ps -q -f name=$LEGACY_NGINX)" ]; then
        echo "Stopping legacy nginx to allow shared stack to start..."
        docker stop $LEGACY_NGINX || true
        docker rm $LEGACY_NGINX || true
    fi

    # Ensure shared services (mongo, nginx) are running
    echo "Checking shared services..."
    docker compose -f docker-compose.shared.$branch.yml -p $PROJECT_PREFIX$branch-shared up -d

    # Determine active color
    ACTIVE_COLOR_FILE="/home/git/active_color_$branch"
    if [ -f "$ACTIVE_COLOR_FILE" ]; then
      CURRENT_COLOR=$(cat "$ACTIVE_COLOR_FILE")
    else
      CURRENT_COLOR="blue"
    fi

    if [ "$CURRENT_COLOR" == "blue" ]; then
      NEW_COLOR="green"
    else
      NEW_COLOR="blue"
    fi

    echo "Current active color: $CURRENT_COLOR"
    echo "Deploying to: $NEW_COLOR"

    # Deploy new stack
    export PROJECT_NAME="$PROJECT_PREFIX$branch-$NEW_COLOR"
    docker compose -f docker-compose.$branch.yml -p $PROJECT_NAME up --build -d
    # verify build status
    if [ $? -ne 0 ]; then
      echo "Build failed! Aborting."
      exit 1
    fi
    
    # Force restart gateway to pick up new subgraph schemas
    docker compose -f docker-compose.$branch.yml -p $PROJECT_NAME restart gateway

    # Wait for new gateway to be healthy
    echo "Waiting for new gateway to be healthy..."
    attempt=0
    max_attempts=60 # 5 minutes
    while [ $attempt -lt $max_attempts ]; do
      # Check if gateway container is running and healthy
      container_name="${PROJECT_NAME}-gateway-1"
      
      # Check if container exists
      if [ -z "$(docker ps -q -f name=$container_name)" ]; then
         echo "Container $container_name not found yet..."
      else
         status=$(docker inspect --format='{{.State.Health.Status}}' $container_name 2>/dev/null)
         if [ "$status" == "healthy" ]; then
           echo "New gateway ($container_name) is healthy."
           break
         fi
         echo "Waiting for gateway health ($status)... ($attempt/$max_attempts)"
      fi
      
      sleep 5
      attempt=$((attempt+1))
    done

    if [ $attempt -eq $max_attempts ]; then
      echo "Gateway failed to become healthy. Aborting deployment."
      docker compose -f docker-compose.$branch.yml -p $PROJECT_NAME down
      exit 1
    fi

    # Update Nginx configuration
    echo "Updating Nginx configuration..."
    
    # Set VIRTUAL_HOST based on branch
    if [ "$branch" == "prod" ]; then
        export VIRTUAL_HOST="clubs.iiit.ac.in"
    else
        export VIRTUAL_HOST="dev-clubs.iiit.ac.in"
    fi

    # Generate app.conf from template    
    envsubst '${PROJECT_NAME} ${VIRTUAL_HOST}' < nginx/app.conf.template > nginx/app.conf

    # Reload Nginx (in shared stack)
    echo "Reloading Nginx..."
    docker compose -f docker-compose.shared.$branch.yml -p $PROJECT_PREFIX$branch-shared exec -T nginx nginx -s reload

    # Update active color file
    echo "$NEW_COLOR" > "$ACTIVE_COLOR_FILE"

    # Stop old stack
    echo "Stopping old stack ($CURRENT_COLOR)..."
    OLD_PROJECT_NAME="$PROJECT_PREFIX$branch-$CURRENT_COLOR"
    docker compose -f docker-compose.$branch.yml -p $OLD_PROJECT_NAME down

    # clean up worktree
    # rm -rf ./services
    # git checkout -f $branch

    echo "Deployed [$branch] successfully to $NEW_COLOR!"
  else
    echo "Ref $ref received. Doing nothing: only [${BRANCHES[*]}] may be deployed on this server."
  fi
done